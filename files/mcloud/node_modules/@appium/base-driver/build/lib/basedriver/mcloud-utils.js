"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getWDAStatus = exports.parseWDAUrl = exports.executeShellWPromise = exports.executeShell = exports.getFileContentLength = exports.getLocalFileForAppUrl = exports.getSharedFolderForAppUrl = exports.getLocalAppsFolder = void 0;
const support_1 = require("@appium/support");
const path_1 = __importDefault(require("path"));
const axios_1 = __importDefault(require("axios"));
const path_2 = __importDefault(require("path"));
const logger_1 = __importDefault(require("./logger"));
const util_1 = __importDefault(require("util"));
const child_process_1 = require("child_process");
async function getLocalAppsFolder() {
    if (process.env.APPIUM_APPS_DIR === undefined || process.env.APPIUM_APPS_DIR === '')
        return undefined;
    else
        return process.env.APPIUM_APPS_DIR;
}
exports.getLocalAppsFolder = getLocalAppsFolder;
async function getSharedFolderForAppUrl(url) {
    const sub = await getLocalFileForAppUrl(url);
    const lastSlashInd = sub.lastIndexOf(path_2.default.sep);
    var targetPath;
    if (lastSlashInd != -1) {
        targetPath = sub.substring(0, lastSlashInd);
    }
    else {
        targetPath = '';
    }
    logger_1.default.info(`[MCLOUD] Target path [getSharedFolderForAppUrl]: ${targetPath}`);
    const folderExists = await support_1.fs.exists(targetPath);
    if (!folderExists)
        await support_1.fs.mkdir(targetPath, { recursive: true });
    return targetPath;
}
exports.getSharedFolderForAppUrl = getSharedFolderForAppUrl;
async function getLocalFileForAppUrl(url) {
    var sub = url.substring(url.indexOf('//') + 2);
    sub = sub.substring(sub.indexOf('/'));
    if (sub.includes('?')) {
        sub = sub.substring(0, sub.indexOf('?'));
    }
    sub = sub.replace(/\//g, path_2.default.sep);
    const targetPath = path_1.default.join(await getLocalAppsFolder(), sub);
    logger_1.default.info(`[MCLOUD] Target path [getLocalFileForAppUrl]: ${targetPath}`);
    return targetPath;
}
exports.getLocalFileForAppUrl = getLocalFileForAppUrl;
async function getFileContentLength(remoteUrl) {
    const timeout = 10000;
    const retries = 5;
    const pollingInterval = 3000;
    const disableAppSizeCheck = process.env.APPIUM_APP_SIZE_DISABLE;
    logger_1.default.info(`[MCLOUD] env APPIUM_APP_SIZE_DISABLE=${disableAppSizeCheck}`);

    if (disableAppSizeCheck === 'True') {
        logger_1.default.debug(`[MCLOUD] Returning app size as undefined`);
        return undefined;
    }

    const requestOpts = {
        url: remoteUrl,
        responseType: 'stream',
        timeout: timeout,
    };
    // getting content-length with retry
    var lastError;
    const getLengthRequest = async () => {
        for (var i = 0; i < retries; i++) {
            try {
                logger_1.default.debug(`[MCLOUD] Making GET http call for retrieving of remote app size`);
                const { headers: responseHeaders, } = await (0, axios_1.default)(requestOpts);
                const responseLength = parseInt(responseHeaders['content-length'], 10);
                logger_1.default.debug(`[MCLOUD] CONTENT-LENGTH for the file: ${responseLength}`);
                return responseLength;
            }
            catch (error) {
                lastError = error;
                console.log(`[MCLOUD] Cannot fetch info about app size. Will retry attempt in ${pollingInterval}ms`);
                await new Promise(resolve => setTimeout(resolve, pollingInterval));
            }
        }
    };
    const length = await getLengthRequest();
    if (length) {
        return length;
    }
    else {
        throw new Error(`[MCLOUD] Cannot get file content-length from ${remoteUrl} after ${retries} retry(s): ${lastError}`);
    }
}
exports.getFileContentLength = getFileContentLength;
function executeShell(shellCommand, description) {
    (0, child_process_1.exec)(shellCommand, (error, stdout, stderr) => {
        if (error) {
            logger_1.default.info(`[MCLOUD] ${description} error: ${error.message}`);
            return;
        }
        if (stderr) {
            logger_1.default.info(`[MCLOUD] ${description} stderr: ${stderr}`);
            return;
        }
        logger_1.default.info(`[MCLOUD] ${description} command was successfully executed`);
    });
}
exports.executeShell = executeShell;
async function executeShellWPromise(shellCommand) {
    const execPromisify = util_1.default.promisify(child_process_1.exec);
    return await execPromisify(shellCommand);
}
exports.executeShellWPromise = executeShellWPromise;
async function parseWDAUrl() {
    const wdaHost = process.env.WDA_HOST;
    const wdaPort = process.env.WDA_PORT;
    return `http://${wdaHost}:${wdaPort}/status`;
}
exports.parseWDAUrl = parseWDAUrl;
async function getWDAStatus(wdaURL) {
    try {
        return (await (0, axios_1.default)({
            url: wdaURL,
            method: 'GET',
            timeout: 500,
        })).data;
    }
    catch (e) {
        logger_1.default.info(`Cannot send GET request to '${wdaURL}'. Original error: ${e.message}`);
        return undefined;
    }
}
exports.getWDAStatus = getWDAStatus;
//# sourceMappingURL=mcloud-utils.js.map
