diff --git a/lib/driver.js b/lib/driver.js
index e6cc6446..af3b165c 100644
--- a/lib/driver.js
+++ b/lib/driver.js
@@ -173,6 +173,8 @@ const MEMOIZED_FUNCTIONS = ['getStatusBarHeight', 'getDevicePixelRatio', 'getScr
 
 const BUNDLE_VERSION_PATTERN = /CFBundleVersion\s+=\s+"?([^(;|")]+)/;
 
+const localAppsFolder = process.env.APPIUM_APPS_DIR;
+
 /**
  * @implements {ExternalDriver<XCUITestDriverConstraints, FullContext|string>}
  * @extends {BaseDriver<XCUITestDriverConstraints>}
@@ -1160,7 +1162,10 @@ class XCUITestDriver extends BaseDriver {
         }
       }
     } finally {
-      await fs.rimraf(rootDir);
+      if (localAppsFolder === undefined || localAppsFolder === '') {
+        this.log.info(`[MCLOUD] XCUITestDriver unzipApp(). Deleting files by path: ${rootDir}`);
+        await fs.rimraf(rootDir);
+      }
     }
     throw new Error(
       `${this.opts.app} did not have any matching ${APP_EXT} or ${IPA_EXT} ` +
@@ -1196,7 +1201,8 @@ class XCUITestDriver extends BaseDriver {
       return {appPath: await this.unzipApp(appPath)};
     } finally {
       // Cleanup previously downloaded archive
-      if (isUrl) {
+      if (isUrl && (localAppsFolder === undefined || localAppsFolder === '')) {
+        this.log.info(`[MCLOUD] XCUITestDriver onPostConfigureApp(). Deleting files by path: ${appPath}`);
         await fs.rimraf(appPath);
       }
     }
diff --git a/lib/ios-deploy.js b/lib/ios-deploy.js
index e5ed93de..0e55e4fa 100644
--- a/lib/ios-deploy.js
+++ b/lib/ios-deploy.js
@@ -13,7 +13,7 @@ const APPLICATION_INSTALLED_NOTIFICATION = 'com.apple.mobile.application_install
 const INSTALLATION_STAGING_DIR = 'PublicStaging';
 const APPLICATION_NOTIFICATION_TIMEOUT_MS = 30 * 1000;
 const IOS_DEPLOY_TIMEOUT_MS = 4 * 60 * 1000;
-const IOS_DEPLOY = 'ios-deploy';
+const IOS_DEPLOY = 'ios';
 const APP_INSTALL_STRATEGY = Object.freeze({
   SERIAL: 'serial',
   PARALLEL: 'parallel',
@@ -26,11 +26,15 @@ class IOSDeploy {
   }
 
   async remove(bundleId) {
-    const service = await services.startInstallationProxyService(this.udid);
     try {
-      await service.uninstallApplication(bundleId);
-    } finally {
-      service.close();
+      await exec(IOS_DEPLOY, [
+        'uninstall', bundleId,
+        '--udid=' + this.udid
+      ]);
+    } catch (err1) {
+      throw new Error(`App is not uninstalled '${bundleId}':\n` +
+        `  - ${err1.message}\n` +
+        `  - ${err1.stderr || err1.stdout || err1.message}`);
     }
   }
 
@@ -67,9 +71,11 @@ class IOSDeploy {
         throw new Error(`'${IOS_DEPLOY}' utility has not been found in PATH. Is it installed?`);
       }
       try {
-        await exec(IOS_DEPLOY, ['--id', this.udid, '--bundle', app], {
-          timeout: timeout ?? IOS_DEPLOY_TIMEOUT_MS,
-        });
+        await exec(IOS_DEPLOY, [
+          'install',
+          '--path=' + app,
+          '--udid=' + this.udid
+        ], {timeout: timeout ?? IOS_DEPLOY_TIMEOUT_MS});
       } catch (err) {
         throw new Error(err.stderr || err.stdout || err.message);
       }
@@ -163,34 +169,43 @@ class IOSDeploy {
    * on the device under test.
    */
   async isAppInstalled(bundleId) {
-    return Boolean(await this.fetchAppInfo(bundleId));
-  }
+    // verify if app installed among system first!
+    try {
+      let {stdout, stderr, code} = await exec(IOS_DEPLOY, [
+        'apps',
+        '--system',
+        '--udid=' + this.udid
+      ]);
+      if (stdout != null && stdout.indexOf(bundleId) !== -1) {
+        log.debug(bundleId + ' is found among system apps.');
+        return true;
+      } else {
+        log.debug(bundleId + ' is NOT found among system apps.');
+      }
+    } catch (err1) {
+      throw new Error(`App is no installed among system apps '${bundleId}':\n` +
+        `  - ${err1.message}\n` +
+        `  - ${err1.stderr || err1.stdout || err1.message}`);
+    }
 
-  /**
-   * Fetches various attributes, like bundle id, version, entitlements etc. of
-   * an installed application.
-   *
-   * @param {string} bundleId the bundle identifier of an app to check
-   * @param {string|string[]|undefined} returnAttributes If provided then
-   * only fetches the requested attributes of the app into the resulting object.
-   * Some apps may have too many attributes, so it makes sense to limit these
-   * by default if you don't need all of them.
-   * @returns {Promise<Object|undefined>} Either app info as an object or undefined
-   * if the app is not found.
-   */
-  async fetchAppInfo(bundleId, returnAttributes = ['CFBundleIdentifier', 'CFBundleVersion']) {
-    const service = await services.startInstallationProxyService(this.udid);
     try {
-      return (
-        await service.lookupApplications({
-          bundleIds: bundleId,
-          // https://github.com/appium/appium/issues/18753
-          returnAttributes,
-        })
-      )[bundleId];
-    } finally {
-      service.close();
+      let {stdout, stderr, code} = await exec(IOS_DEPLOY, [
+        'apps',
+        '--udid=' + this.udid
+      ]);
+      if (stdout != null && stdout.indexOf(bundleId) !== -1) {
+        log.debug(bundleId + ' is found among non system apps.');
+        return true;
+      } else {
+        log.debug(bundleId + ' is NOT found among non system apps.');
+      }
+    } catch (err1) {
+      throw new Error(`App is no installed among non system apps '${bundleId}':\n` +
+        `  - ${err1.message}\n` +
+        `  - ${err1.stderr || err1.stdout || err1.message}`);
     }
+
+    return false;
   }
 
   async terminateApp(bundleId, platformVersion) {
