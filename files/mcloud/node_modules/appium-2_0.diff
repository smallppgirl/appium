diff --git a/packages/base-driver/lib/basedriver/core.ts b/packages/base-driver/lib/basedriver/core.ts
index ddcece947..d55fc2e8f 100644
--- a/packages/base-driver/lib/basedriver/core.ts
+++ b/packages/base-driver/lib/basedriver/core.ts
@@ -23,6 +23,7 @@ import {DEFAULT_BASE_PATH, PROTOCOLS} from '../constants';
 import {errors} from '../protocol';
 import DeviceSettings from './device-settings';
 import helpers, {BASEDRIVER_VER} from './helpers';
+import { executeShellWPromise, parseWDAUrl, getWDAStatus } from './mcloud-utils';
 
 const NEW_COMMAND_TIMEOUT_MS = 60 * 1000;
 
@@ -211,6 +212,59 @@ export class DriverCore<const C extends Constraints, Settings extends StringReco
     return {};
   }
 
+
+  async getStatusWDA (exitCode?: number | null) {
+    const wdaURL = await parseWDAUrl();
+    if (!wdaURL) {
+      throw new Error("Environment variable WDA_ENV is undefined");
+    }
+    const status = await getWDAStatus(wdaURL);
+    if (!status || 'success' != status.value.state) {
+      if (exitCode != null) {
+          this.log.error("Error for sending of WDA status http call. See appium logs for details")
+          this.log.warn(`[MCLOUD] Killing Appium instance with "exit(${exitCode})"`);
+          process.exit(exitCode);
+      }
+      throw new Error("Error for sending of WDA status http call. See appium logs for details");
+    }
+    return {"status": "success", "details": status};
+  }
+    
+  async getStatusADB(exitCode?: number | null) {
+    const deviceUDID = process.env.DEVICE_UDID;
+    if (deviceUDID) {
+      const adbDevicesCmd = 'adb devices | grep $DEVICE_UDID | grep "device"';
+      try {
+        await executeShellWPromise(adbDevicesCmd);
+        return {"status": "success", "details": `Connected device with UDID ${deviceUDID} is ready for execution`};
+      } catch (error) {
+        if (exitCode != null) {
+          this.log.error(`Connected device with UDID ${deviceUDID} is NOT ready for execution. Device was not returned by adb`)
+          this.log.warn(`[MCLOUD] Killing Appium instance with "exit(${exitCode})"`);
+          process.exit(exitCode);
+        }
+        throw new Error(`Connected device with UDID ${deviceUDID} is NOT ready for execution. Device was not returned by adb`);
+      }
+    } else {
+      const deviceName = process.env.ANDROID_DEVICES;
+      if(!deviceName) {
+        throw new Error(`Neither DEVICE_UDID nor ANDROID_DEVICES environment variables were found.`);
+      }
+      const adbDevicesCmd = 'adb devices | grep $ANDROID_DEVICES | grep "device"';
+      try {
+        await executeShellWPromise(adbDevicesCmd);
+        return {"status": "success", "details": `Connected device with name ${deviceName} is ready for execution`};
+      } catch (error) {
+        if (exitCode != null) {
+          this.log.error(`Connected device with UDID ${deviceUDID} is NOT ready for execution. Device was not returned by adb`)
+          this.log.warn(`[MCLOUD] Killing Appium instance with "exit(${exitCode})"`);
+          process.exit(exitCode);
+        }
+        throw new Error(`Connected device with name ${deviceUDID} is NOT ready for execution. Device was not returned by adb`);
+      }
+    }
+  }
+
   /**
    * method required by MJSONWP in order to determine whether it should
    * respond with an invalid session response
diff --git a/packages/base-driver/lib/basedriver/driver.ts b/packages/base-driver/lib/basedriver/driver.ts
index e709c49af..b4ceaa541 100644
--- a/packages/base-driver/lib/basedriver/driver.ts
+++ b/packages/base-driver/lib/basedriver/driver.ts
@@ -312,6 +312,9 @@ export class BaseDriver<
 
     this.log.info(`Session created with session id: ${this.sessionId}`);
 
+    // save current sessionId globally to handle negative use-case instead of desired fallbackSessionId
+    process.env.sessionId = this.sessionId;
+
     return [this.sessionId, caps] as CreateResult;
   }
   async getSessions() {
diff --git a/packages/base-driver/lib/basedriver/helpers.js b/packages/base-driver/lib/basedriver/helpers.js
index 8927032fe..e16e38bbd 100644
--- a/packages/base-driver/lib/basedriver/helpers.js
+++ b/packages/base-driver/lib/basedriver/helpers.js
@@ -7,6 +7,9 @@ import LRU from 'lru-cache';
 import AsyncLock from 'async-lock';
 import axios from 'axios';
 import B from 'bluebird';
+import { getLocalAppsFolder, getSharedFolderForAppUrl, getLocalFileForAppUrl, getFileContentLength } from './mcloud-utils';
+// @ts-ignore
+import { stat } from 'fs';
 
 // for compat with running tests transpiled and in-place
 const {version: BASEDRIVER_VER} = fs.readPackageJsonFrom(__dirname);
@@ -128,6 +131,7 @@ async function configureApp(
   let newApp = app;
   let shouldUnzipApp = false;
   let packageHash = null;
+  let localAppsFolder;
   /** @type {import('axios').AxiosResponse['headers']|undefined} */
   let headers = undefined;
   /** @type {RemoteAppProps} */
@@ -179,6 +183,109 @@ async function configureApp(
             }
           }
         }
+
+        // ***** Custom logic for verification of local static path for APPs *****
+        let downloadIsNeaded = true;
+        localAppsFolder = await getLocalAppsFolder();
+        let localFile;
+        let lockFile;
+        const waitingTime = 1000;
+        const maxAttemptsCount = Number(process.env.APPIUM_APP_WAITING_TIMEOUT);
+        const maxLockFileLifetime = Number(process.env.APPIUM_MAX_LOCK_FILE_LIFETIME);
+        
+        if(localAppsFolder != undefined) {
+          localFile = await getLocalFileForAppUrl(newApp);
+          lockFile = localFile + '.lock';
+
+          if(await fs.exists(localFile)) {
+            logger.info(`[MCLOUD] Local version of app was found. Will check actuality of the file`);
+            // Checking of local application actuality
+            const remoteFileLength = await getFileContentLength(app);
+            // At this point local file might be deleted by parallel session which updates outdated app
+            let attemptsCount = 0;
+            while(!await fs.exists(localFile) && (attemptsCount++ < maxAttemptsCount)) {
+              await new Promise((resolve) => {
+                logger.info(`[MCLOUD] Attempt #${attemptsCount} for local app file to appear again`);
+                setTimeout(resolve, waitingTime);
+              });
+            }
+            if(!await fs.exists(localFile)) {
+              throw Error(`[MCLOUD] Local application file has not appeared after updating by parallel Appium session`);
+            }
+            const stats = await fs.stat(localFile);
+            const localFileLength = stats.size;
+            logger.info(`[MCLOUD] Remote file size is ${remoteFileLength} and local file size is ${localFileLength}`);
+            if(remoteFileLength == undefined) {
+              logger.warn(`[MCLOUD] We could not retrieve remote app size. But since env variable CHECK_APP_SIZE_OPTIONALLY=true old app file will be used.`);
+              newApp = localFile;
+              shouldUnzipApp = ZIP_EXTS.has(path.extname(newApp));
+              downloadIsNeaded = false;
+            } else if(remoteFileLength != localFileLength) {
+              logger.info(`[MCLOUD] Sizes differ. Hence that's needed to download fresh version of the app`);
+              if (await fs.exists(localFile)) {
+                await fs.unlink(localFile);
+              } else {
+                logger.warn(`[MCLOUD] Old local application file ${localFile} was not found. Probably it was removed by another thread which was downloading app in parallel`);
+              }
+              downloadIsNeaded = true;
+            } else {
+              logger.info(`[MCLOUD] Sizes are the same. Hence will use already stored application for the session`);
+              newApp = localFile;
+              shouldUnzipApp = ZIP_EXTS.has(path.extname(newApp));
+              downloadIsNeaded = false;
+            }
+          } else if (await fs.exists(lockFile)) {
+            logger.info(`[MCLOUD] Local version of app not found but .lock file exists. Waiting for .lock to disappear`);
+            // Wait for some time till App is downloaded by some parallel Appium instance
+            let attemptsCount = 0;
+            while(await fs.exists(lockFile) && (attemptsCount++ < maxAttemptsCount)) {
+              const stats = await fs.stat(lockFile);
+              var diffInSeconds = (new Date().getTime() - stats.ctime.getTime()) / 1000;
+
+              if (diffInSeconds >= maxLockFileLifetime) {
+                logger.info(`[MCLOUD] Removing .lock file since its lifetime reached to the limit`);
+                if (await fs.exists(lockFile)) {
+                  await fs.unlink(lockFile);
+                  throw Error(`[MCLOUD] .lock file was removed due to lifetime limit. New download attempt will start for the next session request`);
+                } else {
+                  logger.warn(`[MCLOUD] Lock file ${lockFile} was not found. Probably it was removed by another thread which was downloading app in parallel`);
+                }
+              }
+
+              await new Promise((resolve) => {
+                logger.info(`[MCLOUD] Attempt #${attemptsCount} for .lock file checking`);
+                setTimeout(resolve, waitingTime);
+              });
+            }
+            if(await fs.exists(lockFile)) {
+              throw Error(`[MCLOUD] .lock file for downloading application has not disappeared after ${waitingTime * maxAttemptsCount}ms`);
+            }
+            if(!await fs.exists(localFile)) {
+              throw Error(`[MCLOUD] Local application file has not appeared after .lock file removal`);
+            }
+            logger.info(`[MCLOUD] Local version of app was found after .lock file removal. Will use it for new session`);
+            newApp = localFile;
+            shouldUnzipApp = ZIP_EXTS.has(path.extname(newApp));
+            downloadIsNeaded = false;
+          } else {
+            logger.info(`[MCLOUD] Neither local version of app nor .lock file was found. Will download app from remote URL.`);
+            downloadIsNeaded = true;
+          }
+        } else {
+          logger.info(`[MCLOUD] Local apps folder is not defined via environment properties, hence skipping this logic. Use variable APPIUM_APPS_DIR for path setting`);
+        }
+        if(downloadIsNeaded) {
+        
+          if(localAppsFolder != undefined) {
+            logger.info(`[MCLOUD] Local version of app was not found. Hence using default Appium logic for downloading`);
+            const sharedFolderPath = await getSharedFolderForAppUrl(app);
+            logger.info(`[MCLOUD] Folder for local shared apps: ${sharedFolderPath}`);
+            // @ts-ignore
+            await fs.close(await fs.open(lockFile, 'w'));
+          }
+
+          try {
+
         if (cachedAppInfo && status === HTTP_STATUS_NOT_MODIFIED) {
           if (await isAppIntegrityOk(cachedAppInfo.fullPath, cachedAppInfo.integrity)) {
             logger.info(`Reusing previously downloaded application at '${cachedAppInfo.fullPath}'`);
@@ -252,6 +359,27 @@ async function configureApp(
           suffix: '',
         });
         newApp = await fetchApp(stream, targetPath);
+
+        // ***** Custom logic for copying of downloaded app to static location *****
+        if(localAppsFolder != undefined) {
+          logger.info(`[MCLOUD] New app path: ${newApp}`);
+          // @ts-ignore
+          await fs.copyFile(newApp, localFile);
+        }
+        }
+        finally {
+          if(localAppsFolder != undefined) {
+            logger.info(`[MCLOUD] Going to remove lock file ${lockFile}`)
+            // @ts-ignore
+            if (await fs.exists(lockFile)) {
+              // @ts-ignore
+              await fs.unlink(lockFile);
+            } else {
+              logger.warn(`[MCLOUD] Lock file ${lockFile} was not found. Probably it was removed by another thread which was downloading app in parallel`);
+            }
+          }
+        }
+        }
       } finally {
         if (!stream.closed) {
           stream.destroy();
@@ -282,7 +410,7 @@ async function configureApp(
       if (packageHash === cachedAppInfo?.packageHash) {
         const {fullPath} = cachedAppInfo;
         if (await isAppIntegrityOk(fullPath, cachedAppInfo?.integrity)) {
-          if (archivePath !== app) {
+          if (archivePath !== app && localAppsFolder === undefined) {
             await fs.rimraf(archivePath);
           }
           logger.info(`Will reuse previously cached application at '${fullPath}'`);
@@ -298,7 +426,7 @@ async function configureApp(
       try {
         newApp = await unzipApp(archivePath, tmpRoot, supportedAppExtensions);
       } finally {
-        if (newApp !== archivePath && archivePath !== app) {
+        if (newApp !== archivePath && archivePath !== app && localAppsFolder === undefined) {
           await fs.rimraf(archivePath);
         }
       }
diff --git a/packages/base-driver/lib/basedriver/mcloud-utils.ts b/packages/base-driver/lib/basedriver/mcloud-utils.ts
new file mode 100644
index 000000000..ea48511b0
--- /dev/null
+++ b/packages/base-driver/lib/basedriver/mcloud-utils.ts
@@ -0,0 +1,138 @@
+import {fs} from '@appium/support';
+import nodePath from 'path';
+import axios from 'axios';
+import path from 'path';
+import logger from './logger';
+import util from 'util';
+import { exec } from 'child_process';
+import {
+    type ResponseType
+  } from 'axios';
+
+async function getLocalAppsFolder() {
+    return process.env.APPIUM_APPS_DIR;
+}
+
+async function getSharedFolderForAppUrl(url) {
+    const sub = await getLocalFileForAppUrl(url);
+
+    const lastSlashInd = sub.lastIndexOf(path.sep);
+    var targetPath;
+    if(lastSlashInd != -1) {
+        targetPath = sub.substring(0, lastSlashInd);
+    } else {
+        targetPath = '';
+    }
+
+    logger.info(`[MCLOUD] Target path [getSharedFolderForAppUrl]: ${targetPath}`)
+    const folderExists = await fs.exists(targetPath);
+    if(!folderExists)
+        await fs.mkdir(targetPath, {recursive : true});
+  
+    return targetPath;
+}
+
+async function getLocalFileForAppUrl(url) {
+    var sub = url.substring(url.indexOf('//') + 2)
+    sub = sub.substring(sub.indexOf('/'));
+    if(sub.includes('?')) {
+        sub = sub.substring(0, sub.indexOf('?'));
+    }
+    sub = sub.replace(/\//g, path.sep);
+
+    const targetPath = nodePath.join(await getLocalAppsFolder() as string, sub);
+    logger.info(`[MCLOUD] Target path [getLocalFileForAppUrl]: ${targetPath}`)
+    return targetPath;
+}
+
+async function getFileContentLength(remoteUrl) {
+    const timeout = 10000;
+    const retries = 5;
+    const pollingInterval = 3000;
+    const check_app_size_optionally = process.env.CHECK_APP_SIZE_OPTIONALLY;
+    logger.info(`[MCLOUD] env CHECK_APP_SIZE_OPTIONALLY=${check_app_size_optionally}`);
+
+    const requestOpts = {
+        url: remoteUrl,
+        responseType: 'stream' as ResponseType,
+        timeout: timeout,
+    };
+
+    // getting content-length with retry
+    var lastError;
+    const getLengthRequest = async () => {
+        for (var i=0; i<retries; i++) {
+            try {
+                logger.debug(`[MCLOUD] Making GET http call for retrieving of remote app size`);
+                const {
+                    headers: responseHeaders,
+                } = await axios(requestOpts);
+                const responseLength = parseInt(responseHeaders['content-length'], 10);
+                logger.debug(`[MCLOUD] CONTENT-LENGTH for the file: ${responseLength}`);
+                return responseLength;
+            } catch (error) {
+                lastError = error;
+                console.log(`[MCLOUD] Cannot fetch info about app size. Will retry attempt in ${pollingInterval}ms`);
+                await new Promise(resolve => setTimeout(resolve, pollingInterval));
+            }
+        }
+    }
+    const length = await getLengthRequest();
+    if(length) {
+        return length;
+    } else if (check_app_size_optionally !== undefined && check_app_size_optionally === 'true') {
+        logger.debug(`[MCLOUD] Returning app size as undefined`);
+        return undefined;
+    } else {
+        throw new Error(`[MCLOUD] Cannot get file content-length from ${remoteUrl} after ${retries} retry(s): ${lastError}`);
+    }
+}
+
+function executeShell(shellCommand, description) {
+    exec(shellCommand, (error, stdout, stderr) => {
+        if (error) {
+            logger.info(`[MCLOUD] ${description} error: ${error.message}`);
+            return;
+        }
+        if (stderr) {
+            logger.info(`[MCLOUD] ${description} stderr: ${stderr}`);
+            return;
+        }
+        logger.info(`[MCLOUD] ${description} command was successfully executed`);
+      });
+}
+
+async function executeShellWPromise(shellCommand) {
+    const execPromisify = util.promisify(exec);
+    return await execPromisify(shellCommand);
+}
+
+async function parseWDAUrl() {
+    const wdaHost = process.env.WDA_HOST;
+    const wdaPort = process.env.WDA_PORT;
+    return `http://${wdaHost}:${wdaPort}/status`;
+}
+
+async function getWDAStatus(wdaURL) {
+    try {
+        return (await axios({
+          url: wdaURL,
+          method: 'GET',
+          timeout: 500,
+        })).data;
+      } catch (e) {
+        logger.info(`Cannot send GET request to '${wdaURL}'. Original error: ${e.message}`);
+        return undefined;
+      }
+}
+
+export {
+    getLocalAppsFolder,
+    getSharedFolderForAppUrl,
+    getLocalFileForAppUrl,
+    getFileContentLength,
+    executeShell,
+    executeShellWPromise,
+    parseWDAUrl,
+    getWDAStatus
+}
\ No newline at end of file
diff --git a/packages/base-driver/lib/protocol/protocol.js b/packages/base-driver/lib/protocol/protocol.js
index e0cc73a78..234f43768 100644
--- a/packages/base-driver/lib/protocol/protocol.js
+++ b/packages/base-driver/lib/protocol/protocol.js
@@ -458,6 +458,9 @@ function buildHandler(app, method, path, spec, driver, isSessCmd) {
           })}`
       );
     } catch (err) {
+      // PATCH #2 <appium>/node_modules/appium/node_modules/appium-base-driver/build/lib/protocol/protocol.js to return to carina "DEBUG info" about problematic step
+      err.message = `${err.message}[[[--udid ${process.env.DEVICE_UDID} --name ${process.env.DEVICE_NAME} --sessionId ${process.env.sessionId}]]]`;
+
       // if anything goes wrong, figure out what our response should be
       // based on the type of error that we encountered
       let actualErr;
diff --git a/packages/base-driver/lib/protocol/routes.js b/packages/base-driver/lib/protocol/routes.js
index 2801621eb..f8aa36f0e 100644
--- a/packages/base-driver/lib/protocol/routes.js
+++ b/packages/base-driver/lib/protocol/routes.js
@@ -24,6 +24,12 @@ const METHOD_MAP = /** @type {const} */ ({
   '/status': {
     GET: {command: 'getStatus'},
   },
+  '/status-wda': {
+    GET: {command: 'getStatusWDA', payloadParams: {optional: ['exitCode']}}
+  },
+  '/status-adb': {
+    GET: {command: 'getStatusADB', payloadParams: {optional: ['exitCode']}}
+  },
   '/session': {
     POST: {
       command: 'createSession',
@@ -1012,6 +1018,6 @@ function routeToCommandName(endpoint, method, basePath = DEFAULT_BASE_PATH) {
 }
 
 // driver commands that do not require a session to already exist
-const NO_SESSION_ID_COMMANDS = ['createSession', 'getStatus', 'getSessions'];
+const NO_SESSION_ID_COMMANDS = ['createSession', 'getStatus', 'getStatusWDA', 'getStatusADB', 'getSessions'];
 
 export {METHOD_MAP, ALL_COMMANDS, NO_SESSION_ID_COMMANDS, routeToCommandName};
diff --git a/packages/execute-driver-plugin/lib/plugin.js b/packages/execute-driver-plugin/lib/plugin.js
index 3ac0829c0..c36d89c0a 100644
--- a/packages/execute-driver-plugin/lib/plugin.js
+++ b/packages/execute-driver-plugin/lib/plugin.js
@@ -1,3 +1,4 @@
+// @ts-nocheck
 import {BasePlugin} from 'appium/plugin';
 import _ from 'lodash';
 import cp from 'child_process';
