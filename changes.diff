diff --git a/Dockerfile b/Dockerfile
index 2f2820a..a362a84 100644
--- a/Dockerfile
+++ b/Dockerfile
@@ -31,6 +31,7 @@ ENV ANDROID_DEVICE=
 ENV ADB_POLLING_SEC=5
 
 ENV PROXY_PORT=8080
+ENV SERVER_PROXY_PORT=0
 
 ENV CHROMEDRIVER_AUTODOWNLOAD=true
 
diff --git a/Dockerfile-opencv b/Dockerfile-opencv
index 80098c2..dfc0e7b 100644
--- a/Dockerfile-opencv
+++ b/Dockerfile-opencv
@@ -1,4 +1,4 @@
-FROM public.ecr.aws/zebrunner/appium:2.0.10
+FROM public.ecr.aws/zebrunner/appium:2.0.11
 
 ENV APPIUM_PLUGINS=images
 
diff --git a/device_connect.sh b/device_connect.sh
index 563e495..8b117be 100755
--- a/device_connect.sh
+++ b/device_connect.sh
@@ -84,53 +84,39 @@ if [ "$ANDROID_DEVICE" == "device:5555" ]; then
     fi
 fi
 
-# wait until device is connected and authorized
-available=0
-# to detect negative state
-unauthorized=0
-offline=0
-
 declare -i index=0
 # as default ADB_POLLING_SEC is 5s then we wait for authorizing ~50 sec only
-while [[ $available -eq 0 ]] && [[ $index -lt 10 ]]
+while [[ $index -lt 10 ]]
 do
-    available=`adb devices | grep -c -w device`
-    echo "available: $available"
-
-    if [[ $available -eq 1 ]]; then
-        # do not wait default 5 sec pause if everything is good
-        break
-    fi
-
-    unauthorized=`adb devices | grep -c unauthorized`
-    echo "unauthorized: $unauthorized"
-
-    offline=`adb devices | grep -c offline`
-    echo "offline: $offline"
+    # Possible adb statuses - https://android.googlesource.com/platform/packages/modules/adb/+/refs/heads/main/adb.cpp#118
+    # Possible adb statuses2 - https://android.googlesource.com/platform/packages/modules/adb/+/refs/heads/main/proto/devices.proto#25
+    # UsbNoPermissionsShortHelpText https://android.googlesource.com/platform/system/core/+/refs/heads/main/diagnose_usb/diagnose_usb.cpp#83
+    state=$(adb get-state)
+    case $state in
+        "device")
+            echo "Device connected successfully."
+            break
+        ;;
+        "offline" | "authorizing" | "connecting" | "unknown")
+            echo "Device state: '$state'. One more attempt in $ADB_POLLING_SEC seconds."
+            exit 2
+        ;;
+        "bootloader" | "host" | "recovery" | "rescue" | "sideload" | "unauthorized" | "no permissions"*)
+            echo "Device state: '$state'. There is no reason to try to reconnect."
+            exit 1
+        ;;
+        *)
+            echo "Not documented device state: '$state'. One more attempt in $ADB_POLLING_SEC seconds."
+            exit 2
+        ;;
+    esac
 
     sleep ${ADB_POLLING_SEC}
     index+=1
 done
 
-if [[ $unauthorized -eq 1 ]]; then
-    echo "Device is not authorized!"
-    exit 3
-fi
-
-if [[ $offline -eq 1 ]]; then
-    echo "Device is offline!"
-    exit 2
-fi
-
-if [[ $available -eq 1 ]]; then
-    echo "Device is available"
-else
-    echo "Device is not available!"
-    exit 1
-fi
-
 info=""
-# to support device reboot as device is available by adb but not functionaning correctly.
+# to support device reboot as device is available by adb but not functioning correctly.
 # this extra dumpsys display call guarantees that android is fully booted
 while [[ "$info" == "" ]]
 do
diff --git a/entrypoint.sh b/entrypoint.sh
index 8160b19..c637465 100755
--- a/entrypoint.sh
+++ b/entrypoint.sh
@@ -208,7 +208,6 @@ concatAndroidRecording() {
 }
 
 
-
 capture_video() {
   # use short sleep operations otherwise abort can't be handled via trap/share
   while true; do
@@ -302,22 +301,13 @@ fi
 ${ENTRYPOINT_DIR}/device_connect.sh
 
 ret=$?
-if [ $ret -eq 3 ]; then
-    # unauthorized state
-    echo "Reconnecting..."
-    reconnect
-    exit 0
-fi
-
-if [  $ret -eq 2 ]; then
-    # offline state
+if [ $ret -eq 2 ]; then
     echo "Restarting..."
     reconnect
     exit 1
 fi
 
 if [ $ret -eq 1 ]; then
-    # is not available state due to the unknown reason
     echo "Exiting without restarting..."
     exit 0
 fi
diff --git a/files/mcloud/node_modules/@appium/base-driver/build/lib/basedriver/mcloud-utils.js b/files/mcloud/node_modules/@appium/base-driver/build/lib/basedriver/mcloud-utils.js
index 391d6cd..9a8014e 100644
--- a/files/mcloud/node_modules/@appium/base-driver/build/lib/basedriver/mcloud-utils.js
+++ b/files/mcloud/node_modules/@appium/base-driver/build/lib/basedriver/mcloud-utils.js
@@ -30,8 +30,15 @@ async function getSharedFolderForAppUrl(url) {
     }
     logger_1.default.info(`[MCLOUD] Target path [getSharedFolderForAppUrl]: ${targetPath}`);
     const folderExists = await support_1.fs.exists(targetPath);
-    if (!folderExists)
-        await support_1.fs.mkdir(targetPath, { recursive: true });
+    if (!folderExists){
+        try {
+            await support_1.fs.mkdir(targetPath, { recursive: true });
+            console.log(`The directory ${targetPath} was created successfully.`);
+        } catch (error) {
+            console.error(`Error creating directory ${targetPath}: ${error.message}`);
+            throw new Error(error)
+        }
+    }    
     return targetPath;
 }
 exports.getSharedFolderForAppUrl = getSharedFolderForAppUrl;
diff --git a/files/mcloud/node_modules/@appium/base-driver/build/lib/protocol/protocol.js b/files/mcloud/node_modules/@appium/base-driver/build/lib/protocol/protocol.js
index 7e979d6..b0b4d3a 100644
--- a/files/mcloud/node_modules/@appium/base-driver/build/lib/protocol/protocol.js
+++ b/files/mcloud/node_modules/@appium/base-driver/build/lib/protocol/protocol.js
@@ -392,8 +392,26 @@ function buildHandler(app, method, path, spec, driver, isSessCmd) {
                 })}`);
         }
         catch (err) {
+
             // PATCH #2 <appium>/node_modules/appium/node_modules/appium-base-driver/build/lib/protocol/protocol.js to return to carina "DEBUG info" about problematic step
-            err.message = `${err.message}[[[--udid ${process.env.DEVICE_UDID} --name ${process.env.DEVICE_NAME} --sessionId ${process.env.sessionId}]]]`;
+            if(err.message !== 'An element could not be located on the page using the given search parameters.'){
+                err.message = `${err.message}[[[--udid ${process.env.DEVICE_UDID} --name ${process.env.DEVICE_NAME} --sessionId ${process.env.sessionId}]]]`;
+            }
+            
+            // handling error with ENOSPC: no space left on device, mkdir '/tmp/ and exit with code 1 
+            if(err.message.toLowerCase().includes('no space left on device') || err.message.toLowerCase().includes('adb: failed to install')){
+                console.log(`- [BaseDriver] ENOSPC error, no space left on device, Error message:${err.message} appium exit with code 1`)
+                process.exit(1);
+            }
+          
+            // handling error with Cannot find any free port in range
+            if (err.message.toLowerCase().includes("cannot find any free port in range")) {
+                console.log(`Cannot find any free port in range. Error message: ${err.message} Appium exit with code 1 `);
+                // Exiting with code 1 to indicate an error
+                process.exit(1);
+            }
+
+
             // if anything goes wrong, figure out what our response should be
             // based on the type of error that we encountered
             let actualErr;
diff --git a/files/mcloud/node_modules/appium-2_2_2.diff b/files/mcloud/node_modules/appium-2_2_2.diff
index 46441d6..e192ea4 100644
--- a/files/mcloud/node_modules/appium-2_2_2.diff
+++ b/files/mcloud/node_modules/appium-2_2_2.diff
@@ -365,9 +365,22 @@ index 000000000..b045d4c0f
 +
 +    logger.info(`[MCLOUD] Target path [getSharedFolderForAppUrl]: ${targetPath}`)
 +    const folderExists = await fs.exists(targetPath);
-+    if(!folderExists)
-+        await fs.mkdir(targetPath, {recursive : true});
-+  
++    logger.info(`[MCLOUD] Target path [getSharedFolderForAppUrl]: ${targetPath}`)
++    const folderExists = await fs.exists(targetPath);
+-+    if(!folderExists)
+-+        await fs.mkdir(targetPath, {recursive : true});
+-+  
++-    if(!folderExists)
++-        await fs.mkdir(targetPath, {recursive : true});
+++    if (!folderExists){
+++        try {
+++            await support_1.fs.mkdir(targetPath, { recursive: true });
+++            console.log(`The directory ${targetPath} was created successfully.`);
+++        } catch (error) {
+++            console.error(`Error creating directory ${targetPath}: ${error.message}`);
+++            throw new Error(error)
+++        }
+++    }
 +    return targetPath;
 +}
 +
@@ -480,11 +493,20 @@ index 7eca78cd9..4f8034cad 100644
        );
      } catch (err) {
 +      // PATCH #2 <appium>/node_modules/appium/node_modules/appium-base-driver/build/lib/protocol/protocol.js to return to carina "DEBUG info" about problematic step
-+      err.message = `${err.message}[[[--udid ${process.env.DEVICE_UDID} --name ${process.env.DEVICE_NAME} --sessionId ${process.env.sessionId}]]]`;
-+
-       // if anything goes wrong, figure out what our response should be
-       // based on the type of error that we encountered
-       let actualErr;
+-            err.message = `${err.message}[[[--udid ${process.env.DEVICE_UDID} --name ${process.env.DEVICE_NAME} --sessionId ${process.env.sessionId}]]]`;
++            if(!err.message == 'An element could not be located on the page using the given search parameters.'){
++                err.message = `${err.message}[[[--udid ${process.env.DEVICE_UDID} --name ${process.env.DEVICE_NAME} --sessionId ${process.env.sessionId}]]]`;
++            }
++            
++            // handling error with ENOSPC: no space left on device, mkdir '/tmp/ and exit with code 1 
++            if(err.message.includes('no space left on device') || err.message.includes('adb: failed to install')){
++                console.log(`ENOSPC error, no space left on device, Error message:${err.message} appium exit with code 1`)
++                process.exit(1);
++            }
+             // if anything goes wrong, figure out what our response should be
+             // based on the type of error that we encountered
+             let actualErr;
+
 diff --git a/packages/base-driver/lib/protocol/routes.js b/packages/base-driver/lib/protocol/routes.js
 index 23eacf31c..b810855b6 100644
 --- a/packages/base-driver/lib/protocol/routes.js
diff --git a/files/start-wda.sh b/files/start-wda.sh
index 2428574..b772605 100755
--- a/files/start-wda.sh
+++ b/files/start-wda.sh
@@ -42,45 +42,11 @@ done
 
 if [ $wdaStarted -eq 0 ]; then
   echo "WDA is unhealthy!"
-  cat $WDA_LOG_FILE
   # Destroy appium process as there is no sense to continue with undefined WDA_HOST ip!
   pkill node
   exit 1
 fi
 
-# #247: right after the WDA startup it should load SNAPSHOT of com.apple.springboard default screen and default timeout is 60 sec for 1st start.
-# We have to start this session at once and till next restart WDA sessions might be stopped/started asap.
-echo "[$(date +'%d/%m/%Y %H:%M:%S')] Starting WebDriverAgent 1st session"
-# start new WDA session with default 60 sec snapshot timeout
-sessionFile=/tmp/${DEVICE_UDID}.txt
-curl --silent --location --request POST "http://${WDA_HOST}:${WDA_PORT}/session" --header 'Content-Type: application/json' --data-raw '{"capabilities": {"waitForQuiescence": false}}' > ${sessionFile}
-
-echo "WDA session response:"
-cat ${sessionFile}
-
-bundleId=`cat $sessionFile | grep "CFBundleIdentifier" | cut -d '"' -f 4`
-echo bundleId: $bundleId
-
-sessionId=`cat $sessionFile | grep -m 1 "sessionId" | cut -d '"' -f 4`
-echo sessionId: $sessionId
-
-#TODO: test default bundleId for AppleTV
-if [[ "$bundleId" != "com.apple.springboard" ]]; then
-  echo "[$(date +'%d/%m/%Y %H:%M:%S')] Activating springboard app forcibly"
-  curl --silent --location --request POST "http://${WDA_HOST}:${WDA_PORT}/session/$sessionId/wda/apps/launch" --header 'Content-Type: application/json' --data-raw '{"bundleId": "com.apple.springboard"}'
-  sleep 1
-  curl --silent --location --request POST "http://${WDA_HOST}:${WDA_PORT}/session" --header 'Content-Type: application/json' --data-raw '{"capabilities": {"waitForQuiescence": false}}'
-fi
-
-# #285 do stop for default wda session to improve homescreen activation during usage in STF
-echo "[$(date +'%d/%m/%Y %H:%M:%S')] Stopping 1st default WebDriverAgent session"
-curl --silent --location --request GET "http://${WDA_HOST}:${WDA_PORT}/status"  > ${sessionFile}
-sessionId=`cat $sessionFile | grep -m 1 "sessionId" | cut -d '"' -f 4`
-echo sessionId: $sessionId
-curl --silent --location --request DELETE "http://${WDA_HOST}:${WDA_PORT}/session/${sessionId}"
-
-rm -f ${sessionFile}
-
 #TODO: to  improve better 1st super slow session startup we have to investigate extra xcuitest caps: https://github.com/appium/appium-xcuitest-driver
 #customSnapshotTimeout, waitForIdleTimeout, animationCoolOffTimeout etc
 
